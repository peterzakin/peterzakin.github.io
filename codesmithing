<html>

<body>
    
    <p class="c8"><span>What follows from the fact that </span><span class="c4">LLMs are very good at writing code?</span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span>The first applications that took advantage of this were coding assistants like </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://github.com/features/copilot&amp;sa=D&amp;source=editors&amp;ust=1682295466366774&amp;usg=AOvVaw2mS93BbmLYrZGrdOjQZ7sQ">Copilot</a></span><span class="c4">, which proved remarkably good at code completion. Now Copilot and its siblings are rapidly evolving into other modes of assistance. A few examples:</span></p><p class="c8"><span class="c4">&nbsp;</span></p><ul class="c14 lst-kix_s1fwads4teoe-0 start"><li class="c5 c6 li-bullet-0"><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://replit.com/site/ghostwriter&amp;sa=D&amp;source=editors&amp;ust=1682295466367401&amp;usg=AOvVaw3Q8wcAn53Vag4lHL3VaUga">Replit&rsquo;s Ghostwriter</a></span><span class="c4">&nbsp;offers refactoring help, code explanations that can describe what a block of code is actually doing, and a conversational agent that can answer technical questions etc&hellip;</span></li></ul><p class="c5 c9"><span class="c4"></span></p><ul class="c14 lst-kix_s1fwads4teoe-0"><li class="c5 c6 li-bullet-0"><span>The next version of Github Copilot, </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://github.blog/2023-03-22-github-copilot-x-the-ai-powered-developer-experience/&amp;sa=D&amp;source=editors&amp;ust=1682295466367963&amp;usg=AOvVaw1t7UmEHvMLurILeSaKM8OF">Copilot X</a></span><span>, teases </span><span>a </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://github.blog/wp-content/uploads/2023/03/01-Copilot-Chat-Debug-Blog.mp4?_%3D1)&amp;sa=D&amp;source=editors&amp;ust=1682295466368347&amp;usg=AOvVaw3uLXt8za9W32ws7dXRaumu">conversational interface</a></span><span class="c4">&nbsp;that will explain code, propose bug fixes, or just generally answer your technical questions etc&hellip;</span></li></ul><p class="c5 c9"><span class="c4"></span></p><ul class="c14 lst-kix_s1fwads4teoe-0"><li class="c5 c6 li-bullet-0"><span>Sourcegraph recently released an assistant, aptly named </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://about.sourcegraph.com/cody&amp;sa=D&amp;source=editors&amp;ust=1682295466368917&amp;usg=AOvVaw2JwYod9pSTckgx19aiHrtF">Cody</a></span><span>. Cody manifests both as a code-completer and as a conversational agent that can answer questions pertaining to your codebase or general technical concepts.</span></li></ul><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span>I think of the first chapter of code-intelligent AI work as a story about </span><span>developer productivity.</span><span>&nbsp;We placed smart AI features into IDEs that made it significantly easier for developers to write code. </span><span>But I&rsquo;m starting to think that the next chapter is about AI-based tools using their ability to program to solve higher order problems. Not just generating code but running it. </span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c4">I see this playing out in two important ways. </span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span>The first is that it is going to become much easier for end users to create their own software. </span><span>The second is that </span><span>AI agents will </span><span>be able to satisfy a surprisingly wide range of user requests.</span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c17 c2">LLMs are the holy grail of end-user programming</span></p><p class="c8"><span>Geoffrey Litt wrote an </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://www.geoffreylitt.com/2023/03/25/llm-end-user-programming.html&amp;sa=D&amp;source=editors&amp;ust=1682295466370741&amp;usg=AOvVaw0FB3FUVpGU2tOYjblEWnFA">excellent piece</a></span><span>&nbsp;recently on what AI&rsquo;s talent for writing code might mean for regular users. His basic view is that LLMs being able to write code means that tools are now </span><span class="c15">malleable</span><span class="c4">&nbsp;in a way that might live up to the wildest ideals of end user programming&ndash;that users will be able to mold software without having to resort to the complexity of traditional programming techniques. </span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c4">I&rsquo;d like to unpack what this might look like across a few different forms of software that end-users might build for themselves.</span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c3">Scripting and automation</span></p><p class="c8"><span>A few exciting areas where we&rsquo;ll see LLM-assisted scripting play out: </span></p><p class="c5 c9"><span class="c10 c3"></span></p><ul class="c14 lst-kix_4j7iqv3ctrm4-0 start"><li class="c5 c6 li-bullet-0"><span class="c3">Zapier-style automations. </span><span class="c4">It&rsquo;s easy to imagine that the next generation of workflow automation will either replace or simply augment traditional workflow-builders with natural language.</span></li></ul><p class="c8 c9"><span class="c4"></span></p><p class="c5"><span>Imagine this description for a simple automation: </span><span class="c12">&ldquo;I want to send a slack message to #wins when we close new opportunities.&rdquo; </span></p><p class="c5 c9"><span class="c4"></span></p><p class="c5"><span>From this description, the LLM should be able to deduce the intended logic: that when </span><span class="c4">the stage property of a Salesforce Opportunity record moves to &ldquo;closed&rdquo;, a slack message should be sent to the channel with the name &ldquo;wins&rdquo;. </span></p><p class="c8 c9"><span class="c4"></span></p><p class="c5"><span class="c4">Here&rsquo;s a different example that shows how even complex automations might become much easier to build.</span></p><p class="c5 c9"><span class="c12"></span></p><p class="c5"><span class="c12">&ldquo;I want to send a slack message to the relevant account manager when a customer sends a help message in Zendesk&rdquo;.... </span></p><p class="c5 c9"><span class="c4"></span></p><p class="c5"><span class="c4">Natural language compresses complex ideas. While this description is easy enough to articulate, the logic required to make it happen is actually kind of convoluted. Setting up this automation requires deconstructing &ldquo;relevant account manager&rdquo; into precise logic and some cleverness in making the association between customer records in Zendesk and Salesforce. </span></p><p class="c5 c9"><span class="c4"></span></p><p class="c5"><span>Admittedly, it&rsquo;s possible that the LLM doesn&rsquo;t precisely translate this description into the proper logic. But I imagine that natural language will at least be a useful starting point for automations that are </span><span class="c15">easy to describe, but complex to construct</span><span class="c4">. My hunch is that the product team at Zapier (if not someone else) figures out how to leverage natural language input for much simpler workflow construction. </span></p><p class="c8 c9"><span class="c4"></span></p><p class="c5"><span>I&rsquo;ve written more on the competitive dynamics for workflow automation companies like Zapier here: </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://pzakin.substack.com/p/llms-probably-wont-kill-zapier&amp;sa=D&amp;source=editors&amp;ust=1682295466374144&amp;usg=AOvVaw1v-MplNLh9QEvcV0f_9lsc">https://pzakin.substack.com/p/llms-probably-wont-kill-zapier</a></span><span class="c4">. </span></p><p class="c8"><span>&nbsp;</span></p><ul class="c14 lst-kix_4j7iqv3ctrm4-0"><li class="c5 c6 li-bullet-0"><span class="c3">Natural language interfaces for a</span><span class="c3">pplications with their own custom languages</span><span class="c3">. </span><span class="c4">Application-specific languages are employed across a wide spectrum of applications already: formulas in spreadsheets, codes in GDS systems for travel agents, SQL for data analysis etc&hellip;</span></li></ul><p class="c8 c9"><span class="c4"></span></p><p class="c5"><span class="c4">While these application-specific languages augment the workflows of power users, they often correlate with a higher learning curve for new and less sophisticated users. </span></p><p class="c5 c9"><span class="c4"></span></p><p class="c5"><span class="c4">My sense is that LLM-powered assistants will emerge in these applications, making it easier for end-users to achieve the same kind of control over their tools as power users. </span></p><p class="c5 c9"><span class="c4"></span></p><p class="c5"><span class="c4">Relevant examples: </span></p><ul class="c14 lst-kix_w722rua8i1jl-0 start"><li class="c7 c6 li-bullet-0"><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://twitter.com/bobbypinero/status/1646169304637767680?s%3D20&amp;sa=D&amp;source=editors&amp;ust=1682295466375848&amp;usg=AOvVaw0QMefePtENGAvwplE9tUYB">Command K + GPT</a></span><span>&nbsp;in </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=http://equals.app&amp;sa=D&amp;source=editors&amp;ust=1682295466376232&amp;usg=AOvVaw2vqUvMRZxKI3SDjHuw9iKh">Equals</a></span><span>. </span></li><li class="c7 c6 li-bullet-0"><span>Next-gen developer terminals like </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://fig.io/&amp;sa=D&amp;source=editors&amp;ust=1682295466376799&amp;usg=AOvVaw1Nj8ajKevOtAhG5QsVlzcO">Fig</a></span><span>&nbsp;and </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://www.warp.dev/&amp;sa=D&amp;source=editors&amp;ust=1682295466377143&amp;usg=AOvVaw1PL4kp0ydeNLr-ocbyF8Gh">Warp</a></span><span class="c4">.</span></li><li class="c7 c6 li-bullet-0"><span>Notebook tools like </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://hex.tech/&amp;sa=D&amp;source=editors&amp;ust=1682295466377570&amp;usg=AOvVaw3EczXYYHJB4TripP7kIzqv">Hex</a></span><span>&nbsp;</span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://hex.tech/magic/&amp;sa=D&amp;source=editors&amp;ust=1682295466377858&amp;usg=AOvVaw20-qD_GtTNpcLLcmH21TnB">supporting natural language input.</a></span></li><li class="c7 c6 li-bullet-0"><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://twitter.com/retool/status/1649137621334122497?s%3D20&amp;sa=D&amp;source=editors&amp;ust=1682295466378299&amp;usg=AOvVaw2HiTNsqJcoCad-ptU3NRoK">SQL-oriented assistant</a></span><span>&nbsp;in </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://retool.com/&amp;sa=D&amp;source=editors&amp;ust=1682295466378622&amp;usg=AOvVaw1M2w9dG-n5_3oQ-1vwlnfh">Retool</a></span><span>.</span></li></ul><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c10 c3">Extensibility</span></p><p class="c8"><span class="c4">Customers often need bespoke solutions. The way that software providers accommodate these custom needs is by making their tools extensible. APIs for programmatic use or end-user facing plugins are common approaches here.</span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c4">The problem with extensibility is that it can be hard to take advantage of. Salesforce for instance is intensely configurable, but requires a fair degree of specialized knowledge that most users lack.</span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c4">My sense is that with LLM-assisted coding, end-users will be able to build custom workflows and UI in Salesforce without needing to consult Salesforce Admins or possessing any expertise in Apex code. </span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c4">I can see this playing out similarly with all sorts of other extensible systems: think browser extensions, plugins for Google Docs or blocks in Notion etc&hellip;</span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c4">I wonder if, as extensibility becomes easier, users reveal a preference for apps that are best suited for it. My sense is that they will and that a long term side effect is that developers treat extensibility as a priority. </span></p><p class="c8 c9"><span class="c10 c3"></span></p><p class="c8"><span class="c2">The ability to code amplifies the abilities of AI agents.</span></p><p class="c8"><span>How are we to make sense of something like this </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://twitter.com/gdb/status/1638971232443076609?s%3D20&amp;sa=D&amp;source=editors&amp;ust=1682295466380801&amp;usg=AOvVaw3No9bIEJsaaTIyG0Q0UEtK">demo</a></span><span>&nbsp;from Greg Brockman which features the hard-to-believe phenomenon of an agent writing a script and executing it in order to satisfy a user&rsquo;s request (in this case, to pull out a 5 second clip from a video)</span><span>? </span><span>Is it end-user programming? Or is it just an AI following orders? </span><span><br></span></p><p class="c8"><span class="c4">Consider the following use cases for codesmithing agents:</span></p><p class="c8 c9"><span class="c4"></span></p><ul class="c14 lst-kix_4j7iqv3ctrm4-0"><li class="c5 c6 li-bullet-0"><span class="c3">One-off scripting</span><span class="c3">: </span><span>The most obvious manifestation of agent programming is basically the same kind of end-user programming we discussed earlier except that the context of the request is task delegation rather than software creation. As I&rsquo;ve noted, the line between these things is blurry, but here are a few examples of what I have in mind:</span></li></ul><p class="c5 c9"><span class="c4"></span></p><ul class="c14 lst-kix_4j7iqv3ctrm4-1 start"><li class="c7 c6 li-bullet-0"><span class="c4">&ldquo;I want a list of links that come from tweets I&rsquo;ve liked in the last week. Please add them as a new sub-page inside of my notion reading directory.&rdquo;</span></li></ul><p class="c7 c9"><span class="c4"></span></p><ul class="c14 lst-kix_4j7iqv3ctrm4-1"><li class="c6 c7 li-bullet-0"><span class="c4">&ldquo;Generate a list of every person I met with this week.&rdquo;</span></li></ul><p class="c7 c9"><span class="c4"></span></p><ul class="c14 lst-kix_4j7iqv3ctrm4-1"><li class="c7 c6 li-bullet-0"><span class="c4">&ldquo;Generate a list of everyone I haven&rsquo;t responded to in Slack or Gmail within the last week.&rdquo;</span></li></ul><p class="c8"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c5"><span>Each of these requires some combination of reasoning about a problem and relevant API integrations. As long as agents are equipped with the necessary credentials, these kinds of requests should be doable.</span></p><p class="c8 c9"><span class="c3 c10"></span></p><ul class="c14 lst-kix_p01yqgdn9g8n-0 start"><li class="c5 c6 li-bullet-0"><span class="c3">Autonomous codesmiths in the background.</span></li></ul><p class="c5"><span>I&rsquo;m excited by the possibility of agents residing in the background, </span><span>observing the state of things, and engaging autonomously to advance our goals. </span></p><p class="c5 c9"><span class="c4"></span></p><p class="c5"><span>From a hackathon a few months ago, this project from </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://twitter.com/AlistairPullen&amp;sa=D&amp;source=editors&amp;ust=1682295466383549&amp;usg=AOvVaw37q7NUsZbczFFc1EBy_Y-6">Alistair Pullen</a></span><span>&nbsp;contemplates an AI bug fixer that roams Github Issues and will work to generate pull requests that attempt to resolve them. (</span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://twitter.com/AlistairPullen/status/1617057840459575298?s%3D20&amp;sa=D&amp;source=editors&amp;ust=1682295466383904&amp;usg=AOvVaw27uWX75N7K_VT8uYo_1c4S">https://twitter.com/AlistairPullen/status/1617057840459575298?s=20</a></span><span class="c4">). </span></p><p class="c8 c9"><span class="c4"></span></p><p class="c5"><span class="c4">I am confident we&rsquo;ll see this pattern applied to other developer contexts. We might see new kinds of agent-intervening workflows in task management applications. You could imagine an agent volunteering to work on a Linear task that it thinks it is capable of completing. Or suggesting ways of breaking down a Linear task into smaller tasks that it is suited to work on&hellip;.</span></p><p class="c8 c9"><span class="c10 c3"></span></p><ul class="c14 lst-kix_p01yqgdn9g8n-0"><li class="c5 c6 li-bullet-0"><span class="c10 c3">Agents use code to improve themselves. </span></li></ul><p class="c5"><span>Sometimes agents find that they don&rsquo;t have the tools they need to solve a user request, as in this </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://twitter.com/sjwhitmore/status/1638804650391658501?s%3D20&amp;sa=D&amp;source=editors&amp;ust=1682295466384841&amp;usg=AOvVaw2UMGOmb5D1BIVYUTNHRHUi">highly amusing example</a></span><span>&nbsp;provided by </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://twitter.com/sjwhitmore&amp;sa=D&amp;source=editors&amp;ust=1682295466385140&amp;usg=AOvVaw3fQLIQ0zS3Xk1scIdmsdDl">Sam Whitmore</a></span><span class="c4">. </span></p><p class="c5 c9"><span class="c4"></span></p><p class="c5 c13"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 377.50px; height: 302.48px;"><img alt="" src="images/image1.png" style="width: 377.50px; height: 302.48px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c9"><span class="c4 c19"></span></p><p class="c5"><span class="c4">One possible remedy for agents that find themselves otherwise ill-equipped is to build their own tools. Already, we&rsquo;ve seen a few projects that are pointed in this direction.</span></p><p class="c5 c9"><span class="c4"></span></p><p class="c5"><span>My favorite of this genre is Daniel Gross&rsquo;s </span><span class="c11"><a class="c0" href="https://www.google.com/url?q=https://twitter.com/danielgross/status/1648728342940758016?s%3D20&amp;sa=D&amp;source=editors&amp;ust=1682295466386250&amp;usg=AOvVaw0WNCfMu-i3oSgSpDjUoNrz">LlamaAcademy</a></span><span>. The idea behind LlamaAcademy is that LLMs can potentially learn to how use APIs just by reading through documentation. We can see a horizon where AI agents are capable of integrating into any API as long as the agent is capable of retrieving the relevant documentation (and critically, has access to user credentials). </span></p><p class="c8 c9"><span class="c17 c18"></span></p><p class="c8"><span class="c17 c2 c19">Taking codesmithing to production</span></p><p class="c8"><span class="c4">Agents being able to execute code they&rsquo;ve written themselves is an exciting development that I believe will transform the way we use software.</span></p><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c4">Nevertheless, there are a few issues (beyond any AI Safety concerns) that I anticipate will need to be worked out before codesmithing is production-ready.</span></p><p class="c8 c9"><span class="c4"></span></p><ul class="c14 lst-kix_a20y294ryy5t-0 start"><li class="c5 c6 li-bullet-0"><span class="c3">Access to API credentials. </span><span class="c4">So much of the potential for AI agents writing code has to do with API integrations. As I&rsquo;ve surveyed, there is a great deal of work that points at the possibility of AI being able to write effective integrations. One limiting factor for making this code actually runnable though is access to user credentials. In a world where users have their fair share of available AI agents, I expect that privileged access to user credentials will become strategically important.</span></li></ul><p class="c8 c9"><span class="c4"></span></p><ul class="c14 lst-kix_ulslc8vj1t8r-0 start"><li class="c5 c6 li-bullet-0"><span class="c3">Safe execution of arbitrary code. </span><span class="c4">The production of agent-generated code will pose some measure of security risk. I expect that even as companies are incentivized to make their systems more extensible, they will need to take responsible precautions around the execution of arbitrary code.</span></li></ul><p class="c8 c9"><span class="c4"></span></p><p class="c8"><span class="c15">If this piece resonates or you&rsquo;re building something in this space, feel free to DM </span><span class="c1"><a class="c0" href="https://www.google.com/url?q=http://twitter.com/pzakin&amp;sa=D&amp;source=editors&amp;ust=1682295466388168&amp;usg=AOvVaw0iKiuf2hDP77Xhid3k0pux">me</a></span><span class="c15">&nbsp;on Twitter. I&rsquo;d love to hear from you.</span></p></body></html>
